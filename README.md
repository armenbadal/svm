# Ստեկային վիրտուալ մեքենա

> «Ծրագրավորման լեզուների մշակում եւ իրականացում» դասընթացի համար։

Սա ստեկային վիրտուալ մեքենայի իրականացում է։

Նպատակներս մի քանիսն են.
1. Ստեկային վիրտուալ մեքենայի օրինակով ցուցադրել ֆոն-Նեյմանի ցիկլով աշխատող մեքենայի վարքը։
2. Ասեմբլերի օրինակով ցուցադրել պարզագույն ծրագրավորման լեզվի իրականացման քայլերը։
3. Ապահովել մի մեքենայի մոդել, որի համար ուսումնական կոմպիլյատորը պետք է կոդ գեներացնի։
4. (*) Ուսանողներին տրամադրել մի մեծ «վարժություն», որը կարող են ընդլայնել ու կատարելագործել ըստ իրենց անհատական առաջադրանքների։


## Մեքենայի կառուցվածքը

Վիրտուալ մեքենայի կառուցվածքը հնարավորինս պարզ է։ 

```Go
type Machine struct {
    IP, SP, FP  int16
    memory      []byte
}
```

Այն ունի երեք ռեգիստր.
1. `IP` — _հրամանների հաշվիչ_, սա միշտ ցույց է տալիս հիշողության այն հասցեն, որում գրված հրամանը պետք է կատարվի հերթական քայլում,
2. `SP` — _ստեկի գագաթի ցուցիչ_, այն հասցեն է, որն օգտագործվում են հրամաններ ստեկի հետ աշխատելիս,
3. `FP` — _ֆունկցիայի ակտիվ կանչի կադրի ցուցիչ_, ցույց է տալիս ստեկի այն հատվածը, որում գրված են տվյալ պահին կատարվող ենթածրագրի արգումենտները, լոկալ փոփոխականները ու այլ անհրաժեշտ ինֆորմացիա։

Մեքենայի հիշողությունն ընդհանուր է ծրագրի ու աշխատանքային ստեկի համար։ Ծրագրի բինար ներկայացումը բեռնվում է հիշողության `0` հասցեից, ու `0` հասցեից է սկսվում կատարումը։ Ստեկը սկսվում է ծրագրի կոդից անմիջապես հետո և տարածվում է դեպի մե հասցեները (աջ)։

Հրամանները կոդավորվում են մեկ բայթով. առաջին երկու բիթերով որոշվում է արգումենտի տեսակը։ 
1. `00xxxxxx` — հրամանն արգումենտներ չունի, օգտագործում է ստեկի արժեքները, օրինակ, `ADD`, `PRINT`,
2. `01xxxxxx` — արգումենտն անմիջական տրված 4 բայթանոց ամբողջ թիվ է, օրինակ, `PUSH -12`,
3. `10xxxxxx` — արգումենտն անուղակի հասցե է, զբաղեցնում է 2 բայթ, առաջին երկու բիթով որոշվում է մեքենայի ռեգիստրը (_base_), իսկ մնացած բիթերով ներկայացվում է նշանով արժեք (_displacement_)։ Վերջինս, գումարվելով նշված ռեգիստրի արժեքին, կազմում է բացարձակ հասցեն։

## Ասեմբլերի լեզուն

```text
Program   = { Line }.
Line      = [Label] [Operation] NewLines.
Label     = IDENT ':'.
Operation = 'NOP'
          | 'PUSH' (NUMBER | Indirect)
          | 'POP' Indirect
          | 'CALL' IDENT
          | 'JUMP' IDENT
          | 'JZ' IDENT
          | 'RET'
          | 'HALT'
          | 'INPUT'
          | 'PRINT'
          | 'ADD'
          | 'SUB'
          | 'MUL'
          | 'DIV'
          | 'MOD'
          | 'NEG'
          | 'AND'
          | 'OR'
          | 'NOT'
          | 'EQ'
          | 'NE'
          | 'LT'
          | 'LE'
          | 'GT'
          | 'GE'
          .
NewLines  = '\n' { '\n' }.
Indirect  = '[' Register ('+'|'-') NUMBER ']'.
Register  = 'IP' | 'SP' | 'FP'.
```

### Երկու թվերից մեծը գտնելը

> (ստուգել)

```text
  CALL main
  HALT
main:
  INPUT
  INPUT
  CALL max
  PRINT
  RET
max:
  PUSH [FP - 0]
  PUSH [FP - 1]
  GT
  JZ second
  PUSH [FP - 0]
  JUMP endf
second:
  PUSH [FP - 1]
endf:
  RET
```

## Ասեմբլերը

Ասեմբլերն իրականացված է որպես առանձին մոդուլ, որը վերլուծում է _ասեմբլերի լեզվով_ գրված ծրագիրն ու կառուցում է վիրտուալ մեքենայի կատարման համար պիտանի _բայթ-կոդ_։ Բինար կոդը գեներացնելու համար օգտագործվում է `bytecode` մոդուլի `Builder` օբյեկտը։

## Բինար կոդի կառուցումը

Բինար կոդը կառուցելու համար է նախատեսված `bytecode` փաթեթի `Builder` օբյեկտը։ Այն թույլ է տալիս բինար կոդ կառուցել ծրագրային եղանակով։ Օգտագործվում է _ասեմբլերի_ կողմից, նաև կարող է օգտագործվել բարձր մակարդակի լեզվի կոմպիլյատորի կողմից։
